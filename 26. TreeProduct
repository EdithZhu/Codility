https://app.codility.com/demo/results/training66UMG9-YYW/

import java.util.*;

public class Solution {

    public String solution(int[] A, int[] B) {
        int len = A.length;
        long max = len + 1;
        Tree tree = new Tree(len);
        for (int i = 0; i < len; i++) {
            tree.add(A[i], B[i]);
        }
        tree.split(A[0], B[0]);
        max = Math.max(tree.getCount(), max);
        for (int i = 1; i < len; i++) {
            tree.add(A[i - 1], B[i - 1]);
            tree.split(A[i], B[i]);
            max = Math.max(tree.getCount(), max);
            for (int j = 0; j < i; j++) {
                tree.split(A[j], B[j]);
                max = Math.max(tree.getCount(), max);
                tree.add(A[j], B[j]);
            }
        }
        return String.valueOf(max);
    }

    class Node {
        int position; // guard post number
        int weight; // # of child leaf
        Node parent;
        HashSet<Node> child;

        public Node(int p) {
            this.position = p;
            child = new HashSet<Node>();
            weight = 1;
        }

        void addParent(Node node) {
            parent = node;
        }

        void addChild(Node node) {
            child.add(node);
            addWeight(node.weight);
        }

        void removeParent() {
            parent = null;
        }

        void removeChild(Node node) {
            for (Node p : child) {
                if (p.position == node.position) {
                    child.remove(node);
                    subtractWeight(node.weight);
                    break;
                }
            }
        }

        void addWeight(int val) {
            weight = weight + val;
        }

        void subtractWeight(int val) {
            weight = weight - val;
        }

    }

    
    class Tree implements Cloneable {

        ArrayList<Node> roots;
        Node[] nodeArray;

        public Tree(int n) {
            roots = new ArrayList<Node>();
            nodeArray = new Node[n + 1];
            for (int i = 0; i < n + 1; i++) {
                nodeArray[i] = new Node(i);
            }
        }

        long getCount() {
            long count = 1;
            for (Node p : roots) {
                count *= p.weight;
            }
            return count;
        }

        boolean isRootExist(int position) {
            for (Node p : roots) {
                if (p.position == position) {
                    return true;
                }
            }
            return false;
        }

        void add(int parentP, int childP) {
            LinkedList<Integer> tempListChild = new LinkedList<Integer>();
            tempListChild.add(childP);
            Node tempParentChild = nodeArray[childP].parent;
            while (tempParentChild != null) {
                tempListChild.add(tempParentChild.position);
                tempParentChild = tempParentChild.parent;
            }

            LinkedList<Integer> tempListParent = new LinkedList<Integer>();
            tempListParent.add(parentP);
            Node tempParentParent = nodeArray[parentP].parent;
            while (tempParentParent != null) {
                tempListParent.add(tempParentParent.position);
                tempParentParent = tempParentParent.parent;
            }

            LinkedList<Integer> tempList = tempListChild;
            if (tempListParent.size() < tempListChild.size()) {
                tempList = tempListParent;
                int temp = parentP;
                parentP = childP;
                childP = temp;
            }

            int tempChildP = tempList.getLast();
            roots.remove(nodeArray[tempChildP]);
            if (nodeArray[parentP].parent == null && !isRootExist(parentP)) {
                roots.add(nodeArray[parentP]);
            }
            tempList.removeLast();
            while (tempList.size() != 0) {
                int tempParentP = tempList.getLast();
                nodeArray[tempParentP].removeParent();
                nodeArray[tempChildP].removeChild(nodeArray[tempParentP]);

                connectNode(tempParentP, tempChildP);
                tempChildP = tempParentP;
                tempList.removeLast();
            }

            connectNode(parentP, childP);
            if (isRootExist(childP)) {
                roots.remove(nodeArray[childP]);
            }

        }

        void connectNode(int parentP, int childP) {
            nodeArray[childP].addParent(nodeArray[parentP]);
            nodeArray[parentP].addChild(nodeArray[childP]);
            int childWeight = nodeArray[childP].weight;
            Node parentNode = nodeArray[parentP].parent;
            while (parentNode != null) {
                parentNode.addWeight(childWeight);
                parentNode = parentNode.parent;
            }
        }

        void split(int parentP, int childP) {
            if (nodeArray[childP].parent == null || nodeArray[childP].parent.position != parentP) {
                int temp = parentP;
                parentP = childP;
                childP = temp;
            }
            nodeArray[parentP].removeChild(nodeArray[childP]);
            nodeArray[childP].removeParent();
            int childWeight = nodeArray[childP].weight;
            Node parentNode = nodeArray[parentP].parent;
            while (parentNode != null) {
                parentNode.subtractWeight(childWeight);
                parentNode = parentNode.parent;
            }
            roots.add(nodeArray[childP]);
        }
    }
}
